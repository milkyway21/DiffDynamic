# 分子评估流程文档

## 概述

本文档详细描述了一个分子在 `evaluate_pt_with_correct_reconstruct.py` 中经历的完整评估流程，从输入到输出的所有步骤。

---

## 一、入口和初始化

### 1.1 主函数入口 (`main()`)

**位置**: 第3776行

**流程**:
1. 解析命令行参数（`.pt`文件路径、蛋白质根目录、输出目录等）
2. 验证输入文件是否存在
3. 调用 `evaluate_pt_file()` 开始评估

**关键参数**:
- `pt_file`: 包含生成分子坐标和原子类型的`.pt`文件
- `protein_root`: 蛋白质数据根目录
- `output_dir`: 结果输出目录
- `atom_mode`: 原子编码模式（`basic` 或 `add_aromatic`）
- `exhaustiveness`: AutoDock Vina搜索强度（默认8）
- `save_sdf`: 是否保存SDF文件（默认True）

---

## 二、加载和验证数据

### 2.1 加载`.pt`文件 (`load_pt_file()`)

**位置**: 第450行左右

**流程**:
1. 使用 `torch.load()` 加载`.pt`文件
2. 验证文件是否包含必需字段：
   - `pred_ligand_pos`: 预测的配体坐标
   - `pred_ligand_v`: 预测的配体原子类型
   - `data`: 数据对象（包含`ligand_filename`等）

**输出**:
- `data`: 包含所有数据的字典

### 2.2 验证数据 (`validate_pt_data()`)

**位置**: 第498行

**流程**:
1. 检查必需字段是否存在
2. 验证数据维度是否匹配
3. 打印可用字段信息

---

## 三、准备评估环境

### 3.1 提取信息

**位置**: 第1471-1510行

**提取的信息**:
- `pred_positions`: 预测的分子坐标数组
- `pred_atom_types`: 预测的原子类型数组
- `ligand_filename`: 配体文件名（用于查找参考分子和蛋白质）
- `protein_filename`: 蛋白质文件名（如果存在）
- `data_id`: 数据ID（从`extra_info`或文件名推断）

### 3.2 创建输出目录

**位置**: 第1549-1589行

**创建的目录**:
1. **评估输出目录**: `outputs/eval_{timestamp}_{data_id}_{config_params}/`
   - 包含所有评估结果和统计信息
2. **SDF输出目录**: `eval_output_dir/reconstructed_molecules/`
   - 保存重建成功的分子SDF文件
3. **评分分类目录**（在主路径下）:
   - `molecules_score_65-70/molecules/` 和 `molecules_score_65-70/proteins/`
   - `molecules_score_70-80/molecules/` 和 `molecules_score_70-80/proteins/`
   - `molecules_score_80plus/molecules/` 和 `molecules_score_80plus/proteins/`

---

## 四、分子处理主循环

### 4.1 遍历每个分子

**位置**: 第1652行开始

**流程**:
对每个分子（索引`idx`）执行以下步骤：

---

## 五、分子重建

### 5.1 调用重建函数 (`reconstruct_molecule()`)

**位置**: 第1662行

**函数**: `reconstruct_molecule(pos, v, atom_mode, debug)`

**流程**:
1. **坐标和类型转换**:
   - 将PyTorch张量转换为NumPy数组
   - 如果`v`是one-hot编码，转换为索引

2. **原子类型解码**:
   - 使用`trans.get_atomic_number_from_index()`获取原子序数
   - 使用`trans.is_aromatic_from_index()`获取芳香性标记

3. **调用OpenBabel重建**:
   ```python
   mol = reconstruct.reconstruct_from_generated(
       pos_array.tolist(),      # 坐标列表
       atom_numbers,             # 原子序数列表
       aromatic_flags,           # 芳香性标记列表
       basic_mode=(atom_mode == 'basic')
   )
   ```

4. **重建过程**（在`utils/reconstruct.py`中）:
   - 使用OpenBabel根据坐标和距离连接原子
   - 修复价键错误（降级键级、添加电荷）
   - 重新添加氢原子并生成坐标
   - 执行RDKit Sanitize验证

**输出**:
- `mol`: RDKit分子对象（成功）或`None`（失败）
- `error_info`: 错误信息字典（失败时）

### 5.2 重建失败处理

**位置**: 第1679-1706行

**失败类型**:
- `MolReconsError`: RDKit重建失败
- `reconstruct_returned_none`: 重建函数返回None
- 其他异常

**处理**:
- 记录失败信息到`reconstruct_failures`
- 统计失败类型
- **跳过该分子**（不记录到结果中）

---

## 六、分子评估

### 6.1 调用评估函数 (`evaluate_single_molecule_isolated()`)

**位置**: 第1720行

**说明**: 使用子进程隔离模式，防止底层C++库崩溃影响主进程

**函数**: `evaluate_single_molecule_isolated()` → `evaluate_single_molecule()`

**位置**: 第616行

---

### 6.2 RDKit验证检查

**位置**: 第656-667行

**流程**:
1. 深拷贝分子对象
2. 调用`Chem.SanitizeMol()`验证
3. 记录验证结果：`rdkit_valid` (True/False)

---

### 6.3 化学指标计算

**位置**: 第669-819行

#### 6.3.1 基础化学指标 (`scoring_func.get_chem()`)

**计算内容**:
- **QED**: 类药性评分（0-1）
- **SA**: 合成可及性评分（越低越好，通常0-10）
- **logP**: 脂水分配系数
- **Lipinski规则得分**: 符合Lipinski五规则的项数（0-5）

**存储**: `result['chem']`, `result['logp']`, `result['lipinski']`

#### 6.3.2 TPSA（拓扑极性表面积）

**位置**: 第677-685行

**计算**: `Descriptors.TPSA(mol)`

**存储**: `result['tpsa']`

#### 6.3.3 基础结构信息 (`scoring_func.get_basic()`)

**位置**: 第687-700行

**计算内容**:
- 原子数 (`n_atoms`)
- 键数 (`n_bonds`)
- 环数 (`n_rings`)
- 分子量 (`weight`)

**存储**: `result['basic_info']`

#### 6.3.4 PAINS检测 (`scoring_func.is_pains()`)

**位置**: 第702-710行

**检测**: 是否包含PAINS（泛活性干扰化合物）模式

**存储**: `result['pains']` (True/False)

#### 6.3.5 稳定性评估 (`analyze.check_stability()`)

**位置**: 第712-730行

**流程**:
1. 获取分子坐标和原子类型
2. 转换为analyze模块使用的编码格式
3. 调用`analyze.check_stability()`检查：
   - 基于坐标推断键级
   - 检查是否符合价键规则
   - 统计稳定原子数

**输出**:
- `molecule_stable`: 分子是否稳定（布尔值）
- `nr_stable_bonds`: 稳定原子数
- `n_atoms`: 总原子数
- `nr_bonds`: 每个原子的键数（可选）

**存储**: `result['stability']`

#### 6.3.6 Tanimoto相似度

**位置**: 第732-756行

**流程**:
1. 从`ligand_filename`加载参考分子
2. 使用`similarity.tanimoto_sim()`计算相似度

**存储**: `result['tanimoto_sim']`

#### 6.3.7 RDKit RMSD

**位置**: 第758-770行

**计算**: `scoring_func.get_rdkit_rmsd(mol, n_conf=20)`

**输出**:
- 最大RMSD
- 最小RMSD
- 中位数RMSD

**存储**: `result['rdkit_rmsd']`

#### 6.3.8 构象能量

**位置**: 第772-786行

**流程**:
1. 添加氢原子 (`Chem.AddHs()`)
2. 生成多个构象 (`EmbedMultipleConfs()`)
3. 计算MMFF力场能量 (`get_conformer_energies()`)

**存储**: `result['conformer_energy']`

#### 6.3.9 Lilly Medchem Rules评估

**位置**: 第788-818行

**函数**: `evaluate_lilly_medchem_rules(mol)`

**评估内容**:
- 原子数量限制
- 基本要求（C、O/N原子）
- 禁止元素
- 同位素检查
- 直接拒绝规则（SMARTS模式）
- 扣分规则（SMARTS模式）

**输出**:
- `passed`: 是否通过（布尔值）
- `demerit`: 扣分数（整数）
- `reject_reason`: 拒绝原因（字符串）
- `matched_rules`: 匹配的规则列表

**存储**:
- `result['lilly_medchem_passed']`
- `result['lilly_medchem_demerit']`
- `result['lilly_medchem_description']`（描述字符串）

---

### 6.4 生成SMILES

**位置**: 第820-831行

**流程**:
1. 使用`Chem.MolToSmiles(mol)`生成SMILES字符串
2. 检查是否是片段化分子（包含`.`）
3. 如果是片段，跳过后续评估

**存储**: `result['smiles']`

---

### 6.5 分子结构指标计算

**位置**: 第833-879行

#### 6.5.1 原子类型分布JSD

**位置**: 第838-847行

**计算**:
- 统计原子类型分布
- 使用`eval_atom_type.eval_atom_type_distribution()`计算JSD

**存储**: `result['atom_type_jsd']`

#### 6.5.2 键长分布JSD

**位置**: 第849-862行

**计算**:
- 从分子提取键长距离
- 生成键长分布轮廓
- 使用`eval_bond_length.eval_bond_length_profile()`计算JSD

**存储**: `result['bond_length_jsd']`（字典）

#### 6.5.3 原子对距离分布JSD

**位置**: 第864-879行

**计算**:
- 从坐标和原子类型计算所有原子对距离
- 生成原子对距离分布轮廓
- 使用`eval_bond_length.eval_pair_length_profile()`计算JSD

**存储**: `result['pair_length_jsd']`（字典）

---

### 6.6 AutoDock Vina对接

**位置**: 第881-980行

#### 6.6.1 创建对接任务

**位置**: 第908-915行

**流程**:
1. 为每个分子创建独立的临时目录（避免并行冲突）
2. 使用`VinaDockingTask.from_generated_mol()`创建对接任务

**临时目录格式**: `docktmp/tmp_docking_{pocket_id}_{timestamp}/mol_{process_id}_{thread_id}_{microsecond_timestamp}/`

#### 6.6.2 Dock模式（完整对接）

**位置**: 第923-933行

**流程**:
1. 调用`vina_task.run(mode='dock', exhaustiveness=exhaustiveness, n_poses=n_poses)`
2. 执行完整的AutoDock Vina对接搜索
3. 返回多个对接姿势及其亲和力分数

**输出**: `result['vina_dock']`（列表，每个元素包含`affinity`和`rmsd`）

#### 6.6.3 Score Only模式（仅打分）

**位置**: 第935-949行

**流程**:
1. 调用`vina_task.run(mode='score_only')`
2. 对当前构象进行打分（不搜索）
3. 返回亲和力分数

**输出**: `result['vina_score_only']`（浮点数）

#### 6.6.4 Minimize模式（能量最小化）

**位置**: 第951-965行

**流程**:
1. 调用`vina_task.run(mode='minimize')`
2. 对分子进行能量最小化
3. 返回最小化后的亲和力分数

**输出**: `result['vina_minimize']`（浮点数）

#### 6.6.5 对接失败处理

**位置**: 第917-980行

**处理**:
- 收集所有对接失败的错误信息
- 记录到`docking_errors`列表
- 继续执行其他评估步骤

---

### 6.7 评估结果汇总

**位置**: 第982-1000行

**流程**:
1. 检查是否有任何对接结果成功
2. 设置`result['success'] = True/False`
3. 返回完整的评估结果字典

---

## 七、综合评分计算

### 7.1 计算综合评分 (`calculate_comprehensive_score()`)

**位置**: 第1868行

**函数**: `calculate_comprehensive_score(eval_result)`

**位置**: 第93-168行

**公式**: `100 * (基础分加权和) * PAINS惩罚 * 稳定性惩罚`

#### 7.1.1 Vina亲和力归一化

**位置**: 第105-121行

**公式**: `MAX(0, MIN(1, (-affinity - 6) / 6))`

**含义**:
- -6 kcal/mol以下开始得分
- -12 kcal/mol拿满分（1.0）
- 亲和力越小（越负）越好

#### 7.1.2 基础分加权和

**位置**: 第123-145行

**权重**:
- 亲和力归一化: 40%
- QED: 30%
- SA归一化: 20%
- Lipinski规则得分/5: 10%

**公式**:
```python
base_score = (
    0.4 * affinity_norm +
    0.3 * qed +
    0.2 * sa_normalized +
    0.1 * (lipinski / 5.0)
)
```

#### 7.1.3 惩罚系数

**位置**: 第147-163行

**PAINS惩罚**:
- 如果检测到PAINS: `pains_multiplier = 0.5`
- 否则: `pains_multiplier = 1.0`

**稳定性惩罚**:
- 如果分子不稳定: `stability_multiplier = 0.9`
- 否则: `stability_multiplier = 1.0`

#### 7.1.4 最终得分

**位置**: 第165-168行

**公式**: `final_score = 100.0 * base_score * pains_multiplier * stability_multiplier`

**存储**: `eval_result['comprehensive_score']`

---

### 7.2 生成分子身份证

**位置**: 第1871-1876行

#### 7.2.1 提取蛋白质ID (`extract_protein_id()`)

**位置**: 第171-209行

**流程**:
1. 优先从`protein_filename`提取4位字母数字ID
2. 如果失败，从`ligand_filename`提取
3. 如果都失败，返回`'UNKNOWN'`

#### 7.2.2 生成分子ID (`generate_molecule_id()`)

**位置**: 第212-254行

**格式**: `{蛋白质ID}_{生成时间}_{分子评分}`

**示例**: `1A4K_20240101_123456_88p89`

**流程**:
1. 格式化蛋白质ID（确保4位，大写）
2. 格式化生成时间（`YYYYMMDD_HHMMSS`）
3. 格式化评分（保留2位小数，用`p`代替小数点）
   - 例如：`88.89` → `88p89`
   - 整数：`80` → `80p00`

**存储**: `eval_result['molecule_id']`

---

## 八、保存结果

### 8.1 保存SDF文件

**位置**: 第1889-1990行

**条件**: `save_sdf and sdf_dir and mol is not None`

**流程**:
1. **生成文件名**: 使用分子身份证作为文件名
   ```python
   sdf_path = sdf_dir / f'{molecule_id}.sdf'
   ```

2. **添加分子属性**:
   - `SMILES`: SMILES字符串
   - `QED`: QED评分
   - `SA`: SA评分
   - `Vina_Dock`: Dock模式亲和力
   - `Vina_ScoreOnly`: Score Only模式亲和力
   - `Vina_Minimize`: Minimize模式亲和力
   - `Molecule_Index`: 分子索引
   - `Comprehensive_Score`: 综合评分
   - `Molecule_ID`: 分子身份证

3. **写入SDF文件**: 使用`Chem.SDWriter()`

---

### 8.2 根据评分分类和复制文件

**位置**: 第1921-1986行

**流程**:
1. **确定评分分类**:
   - 65 ≤ 评分 < 70: `category = '65-70'`
   - 70 ≤ 评分 < 80: `category = '70-80'`
   - 评分 ≥ 80: `category = '80+'`

2. **复制SDF文件**:
   ```python
   target_sdf_path = score_category_dirs[category] / 'molecules' / f'{molecule_id}.sdf'
   shutil.copy2(sdf_path, target_sdf_path)
   ```

3. **复制蛋白质文件**:
   - 搜索蛋白质文件路径（尝试多个可能位置）
   - 如果找到，复制到`score_category_dirs[category] / 'proteins' /`
   - 如果目标文件已存在，跳过（避免重复复制）

---

### 8.3 保存评估结果到列表

**位置**: 第1992-2019行

**流程**:
1. 将评估结果添加到`results`列表
2. 包含所有评估指标和分子对象

**注意**: 只有重建成功的分子才会被添加到`results`列表

---

### 8.4 定期保存中间结果

**位置**: 第2022-2049行

**触发条件**: 每处理16个分子

**函数**: `save_intermediate_results()`

**保存内容**:
- Excel文件（包含所有评估结果）
- JSON统计文件
- 重建失败统计

---

## 九、最终统计和保存

### 9.1 统计信息

**位置**: 第2092-2136行

**统计内容**:
- 总样本数
- 重建成功率
- 评估成功率
- 完整分子数（非片段）
- 重建失败详细统计（按失败类型分类）

### 9.2 保存最终结果

**位置**: 第2147行开始

**函数**: `save_intermediate_results(is_final=True)`

**保存内容**:
1. **Excel文件**: `eval_results_{timestamp}.xlsx`
   - 包含所有分子的详细评估结果
   - 多个工作表（结果、统计、失败信息等）

2. **JSON文件**: `eval_stats_{timestamp}.json`
   - 包含统计信息和配置参数

3. **重建失败信息**: `reconstruct_failures_{timestamp}.json`
   - 包含所有重建失败的详细信息

---

## 十、错误处理和异常情况

### 10.1 重建失败

**处理**: 跳过该分子，不记录到结果中

**统计**: 记录失败类型和详细信息

### 10.2 评估失败

**处理**: 
- 记录失败信息
- 继续处理下一个分子
- 保存部分结果（标记为失败）

### 10.3 用户中断

**处理**: 
- 捕获`KeyboardInterrupt`
- 保存已处理的结果
- 调用`save_on_exit()`函数

### 10.4 子进程隔离

**位置**: `evaluate_single_molecule_isolated()`

**目的**: 防止底层C++库（AutoDock Vina、RDKit）崩溃影响主进程

**实现**: 使用`multiprocessing`创建独立子进程

---

## 十一、输出文件结构

```
outputs/
└── eval_{timestamp}_{data_id}_{config_params}/
    ├── reconstructed_molecules/          # SDF文件目录
    │   ├── {protein_id}_{time}_{score}.sdf
    │   └── ...
    ├── eval_results_{timestamp}.xlsx    # Excel结果文件
    ├── eval_stats_{timestamp}.json      # JSON统计文件
    └── reconstruct_failures_{timestamp}.json  # 失败信息

molecules_score_65-70/                    # 评分分类目录（主路径）
├── molecules/
│   └── {molecule_id}.sdf
└── proteins/
    └── {protein_filename}.pdb

molecules_score_70-80/
├── molecules/
└── proteins/

molecules_score_80plus/
├── molecules/
└── proteins/
```

---

## 十二、关键评估指标总结

### 12.1 化学指标
- **QED**: 类药性评分（0-1）
- **SA**: 合成可及性评分
- **logP**: 脂水分配系数
- **Lipinski规则**: 符合规则数（0-5）
- **TPSA**: 拓扑极性表面积

### 12.2 对接指标
- **Vina Dock**: 完整对接亲和力（kcal/mol）
- **Vina Score Only**: 仅打分亲和力
- **Vina Minimize**: 最小化后亲和力

### 12.3 结构指标
- **原子类型分布JSD**: 与训练数据分布的差异
- **键长分布JSD**: 键长分布合理性
- **原子对距离分布JSD**: 原子间距离分布合理性

### 12.4 稳定性指标
- **分子稳定性**: 基于坐标推断的价键规则符合性
- **稳定原子数**: 符合价键规则的原子数

### 12.5 药物化学规则
- **Lilly Medchem Rules**: 是否通过、扣分数、匹配规则

### 12.6 综合评分
- **综合模型评分**: 加权综合评分（0-100）
  - 公式: `100 * (0.4*亲和力 + 0.3*QED + 0.2*SA + 0.1*Lipinski) * PAINS惩罚 * 稳定性惩罚`

---

## 十三、流程总结

一个分子在评估系统中的完整流程：

1. **加载** → 从`.pt`文件加载坐标和原子类型
2. **重建** → 使用OpenBabel重建3D分子结构
3. **验证** → RDKit验证分子有效性
4. **化学评估** → 计算QED、SA、logP、Lipinski等指标
5. **结构评估** → 计算原子类型、键长、距离分布JSD
6. **稳定性评估** → 检查价键规则符合性
7. **药物化学规则** → Lilly Medchem Rules评估
8. **对接评估** → AutoDock Vina三种模式对接
9. **综合评分** → 计算加权综合评分
10. **生成ID** → 生成分子身份证
11. **保存** → 保存SDF文件和评估结果
12. **分类** → 根据评分分类并复制文件

整个过程确保每个分子都经过全面的化学、结构和对接评估，最终生成可用的药物候选分子。

---

## 附录：关键函数索引

- `load_pt_file()`: 加载`.pt`文件
- `validate_pt_data()`: 验证数据
- `reconstruct_molecule()`: 重建分子
- `evaluate_single_molecule()`: 评估单个分子
- `calculate_comprehensive_score()`: 计算综合评分
- `extract_protein_id()`: 提取蛋白质ID
- `generate_molecule_id()`: 生成分子身份证
- `save_intermediate_results()`: 保存中间结果
- `evaluate_pt_file()`: 评估整个`.pt`文件
- `main()`: 主函数入口

---

**文档版本**: 1.0  
**最后更新**: 2024年  
**对应代码**: `evaluate_pt_with_correct_reconstruct.py`

