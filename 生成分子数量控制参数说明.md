# 生成分子数量控制参数说明

## 概述

本文档详细说明控制每个蛋白质靶点生成分子数量的所有参数及其作用机制。

---

## 核心参数（直接控制最终生成数量）

### 1. `num_samples` ⭐ **最重要**
- **位置**: `configs/sampling.yml` → `sample.num_samples`
- **当前值**: `100`
- **作用**: **直接控制每个靶点最终生成的分子总数**
- **代码位置**: `scripts/sample_diffusion.py:228`
  ```python
  num_samples = config.sample.get('num_samples', 1)  # 生成样本数量
  for sample_idx in range(num_samples):  # 逐个生成样本
  ```
- **说明**: 
  - 这是**最直接**的参数，控制循环次数
  - 在动态采样模式下，每个循环生成1个分子
  - **最终输出分子数 = num_samples**

---

## 动态采样模式下的候选生成参数

### 2. `large_step.batch_size`
- **位置**: `configs/sampling.yml` → `sample.dynamic.large_step.batch_size`
- **当前值**: `20`
- **作用**: 控制large_step阶段每批并行生成的候选数量
- **代码位置**: `scripts/sample_diffusion.py:556`
  ```python
  large_batch_size = large_cfg.get('batch_size', config.sample.get('batch_size', 16))
  ```
- **说明**:
  - 在large_step阶段，每次并行生成 `batch_size` 个候选
  - 这些候选会在refine阶段进一步处理
  - **注意**: 如果启用筛选，最终保留的候选数可能少于生成数

### 3. `large_step.n_repeat`
- **位置**: `configs/sampling.yml` → `sample.dynamic.large_step.n_repeat`
- **当前值**: `1`
- **作用**: large_step阶段的重复执行次数
- **代码位置**: `scripts/sample_diffusion.py:557, 574`
  ```python
  n_repeat = large_cfg.get('n_repeat', 1)
  for repeat_idx in range(n_repeat):  # 逐次执行大步探索
  ```
- **说明**:
  - 每次repeat会生成 `batch_size` 个候选
  - **large_step阶段总候选数 = batch_size × n_repeat**
  - 例如: `batch_size=20, n_repeat=1` → 生成20个候选
  - 例如: `batch_size=20, n_repeat=5` → 生成100个候选

### 4. `refine.n_sampling`
- **位置**: `configs/sampling.yml` → `sample.dynamic.refine.n_sampling`
- **当前值**: `1`
- **作用**: 对每个候选进行refine的次数
- **代码位置**: `scripts/sample_diffusion.py:994, 1002, 1077`
  ```python
  n_sampling = max(refine_cfg.get('n_sampling', 1), 1)
  for refine_idx in range(n_sampling):  # 对每个候选执行多次精炼采样
  ```
- **说明**:
  - 每个候选会被refine `n_sampling` 次
  - **refine后总候选数 = large_step候选数 × n_sampling**
  - 例如: large_step有20个候选，`n_sampling=1` → refine后仍为20个
  - 例如: large_step有20个候选，`n_sampling=5` → refine后变为100个

### 5. `refine.cycles`
- **位置**: `configs/sampling.yml` → `sample.dynamic.refine.cycles`
- **当前值**: `1`
- **作用**: refine阶段的循环次数（内部循环）
- **说明**:
  - 影响refine的深度，但不直接改变候选数量
  - 主要用于提高refine质量

---

## 筛选参数（控制最终保留数量）

### 6. `selector.enable_selection`
- **位置**: `configs/sampling.yml` → `sample.dynamic.selector.enable_selection`
- **当前值**: `false`
- **作用**: 是否启用候选筛选
- **说明**:
  - `true`: 启用筛选，只保留top_n个最优候选
  - `false`: 不筛选，保留所有生成的候选

### 7. `selector.top_n`
- **位置**: `configs/sampling.yml` → `sample.dynamic.selector.top_n`
- **当前值**: `20`
- **作用**: 如果启用筛选，保留前N个最优候选
- **代码位置**: `scripts/sample_diffusion.py:select_top_candidates()`
- **说明**:
  - 只在 `enable_selection=true` 时生效
  - 根据QED和SA评分选择top_n个候选
  - **最终输出数 ≤ top_n**（如果生成的候选数少于top_n，则全部保留）

### 8. `selector.selection_time`
- **位置**: `configs/sampling.yml` → `sample.dynamic.selector.selection_time`
- **当前值**: `250`
- **作用**: 筛选的时间节点（在t=250时进行筛选）
- **说明**:
  - 在refine阶段的中间位置进行筛选
  - 提前淘汰低质量候选，节省计算资源

---

## 参数关系总结

### 动态采样模式下的分子生成流程：

```
1. Large Step阶段:
   生成候选数 = batch_size × n_repeat
   例如: 20 × 1 = 20个候选

2. Refine阶段:
   精炼后候选数 = large_step候选数 × n_sampling
   例如: 20 × 1 = 20个候选

3. 筛选阶段（如果启用）:
   最终候选数 = min(精炼后候选数, top_n)
   例如: min(20, 20) = 20个候选

4. 最终输出:
   如果 enable_selection=false: 输出所有精炼后的候选
   如果 enable_selection=true: 输出筛选后的top_n个候选
```

### 当前配置下的生成数量：

```
当前配置:
- num_samples: 100
- batch_size: 20
- n_repeat: 1
- n_sampling: 1
- enable_selection: false
- top_n: 20

生成流程:
1. Large Step: 20 × 1 = 20个候选
2. Refine: 20 × 1 = 20个候选
3. 筛选: 未启用，保留所有20个候选

但是！由于 num_samples=100，会循环100次，每次生成20个候选
最终输出: 100 × 20 = 2000个候选（如果未启用筛选）
```

**⚠️ 重要说明**: 

动态采样有两种模式，控制方式不同：

### 模式1: Unified Dynamic（统一动态模式，默认）
- 当 `dynamic.method = "auto"` 或 `"unified"` 时使用
- `num_samples` 直接控制生成分子数
- 每次循环生成1个分子
- **实际输出分子数 = num_samples**
- `batch_size`、`n_repeat`、`n_sampling` 在此模式下**不直接影响最终数量**

### 模式2: Legacy Dynamic（传统动态模式）
- 当 `dynamic.method = "legacy"` 时使用
- 使用 `batch_size`、`n_repeat`、`n_sampling` 控制候选生成
- **实际输出分子数 = batch_size × n_repeat × n_sampling**
- 如果启用筛选: **实际输出分子数 = min(batch_size × n_repeat × n_sampling, top_n)**
- `num_samples` 在此模式下**可能不被使用**（取决于具体实现）

**当前配置**: `method: auto` → 自动选择，通常使用Unified模式
**因此**: `num_samples=100` → **生成100个分子** ✅

---

## 推荐配置方案

### 方案1: 每个靶点生成100个分子（当前需求）
```yaml
num_samples: 100
large_step:
  batch_size: 20
  n_repeat: 1
refine:
  n_sampling: 1
selector:
  enable_selection: false  # 不筛选，保留所有
```
**结果**: 100 × 20 × 1 × 1 = **2000个候选**（太多！）

**修正方案**:
```yaml
num_samples: 5  # 减少循环次数
large_step:
  batch_size: 20
  n_repeat: 1
refine:
  n_sampling: 1
selector:
  enable_selection: false
```
**结果**: 5 × 20 × 1 × 1 = **100个候选** ✅

### 方案2: 使用筛选机制
```yaml
num_samples: 5
large_step:
  batch_size: 20
  n_repeat: 1
refine:
  n_sampling: 1
selector:
  enable_selection: true
  top_n: 20
```
**结果**: 5 × min(20, 20) = **100个候选**（每个循环保留20个最优）✅

### 方案3: 使用n_repeat增加候选多样性
```yaml
num_samples: 10
large_step:
  batch_size: 10
  n_repeat: 1
refine:
  n_sampling: 1
selector:
  enable_selection: true
  top_n: 10
```
**结果**: 10 × min(10, 10) = **100个候选** ✅

---

## 参数调整建议

1. **如果只想生成100个分子**:
   - 设置 `num_samples × batch_size × n_repeat × n_sampling = 100`
   - 推荐: `num_samples=5, batch_size=20, n_repeat=1, n_sampling=1`

2. **如果想提高质量（使用筛选）**:
   - 设置 `enable_selection=true`
   - 设置合理的 `top_n` 值（如20）
   - 增加 `num_samples` 或 `batch_size` 以生成更多候选供筛选

3. **如果想增加候选多样性**:
   - 增加 `n_repeat`（多次large_step探索）
   - 增加 `n_sampling`（多次refine）

4. **如果GPU内存有限**:
   - 减少 `batch_size`（如16或10）
   - 相应增加 `num_samples` 或 `n_repeat` 以保持总数量

---

## 代码位置参考

- `scripts/sample_diffusion.py:228` - num_samples读取
- `scripts/sample_diffusion.py:244` - num_samples循环
- `scripts/sample_diffusion.py:556` - batch_size读取
- `scripts/sample_diffusion.py:557` - n_repeat读取
- `scripts/sample_diffusion.py:574` - n_repeat循环
- `scripts/sample_diffusion.py:994` - n_sampling读取
- `scripts/sample_diffusion.py:1002, 1077` - n_sampling循环
- `scripts/sample_diffusion.py:select_top_candidates()` - 筛选逻辑

