# 残留进程原因分析

## 问题现象
在运行 `batch_sampleandeval_parallel.py` 后，系统中会残留大量进程：
- `batch_sampleandeval_parallel.py` 主进程和子进程
- `sample_diffusion.py` 采样进程
- `evaluate_pt_with_correct_reconstruct.py` 评估进程

## 根本原因

### 1. **进程被挂起（Stopped/Suspended）**
从 `ps aux` 输出可以看到，很多进程的状态是 `Tl` 或 `T`：
- `T`: 进程被停止（stopped）
- `l`: 多线程进程

**原因**：
- 进程可能因为收到 `SIGSTOP` 信号被挂起
- 进程在等待某些资源（如GPU内存）时被系统挂起
- 进程因为CUDA错误或其他异常进入不可中断的睡眠状态

### 2. **multiprocessing.Pool 的进程管理问题**

代码使用了 `with Pool()` 上下文管理器：
```python
with Pool(processes=num_gpus) as pool:
    sampling_results = pool.map(process_sampling_task, sampling_tasks)
```

**潜在问题**：
- 如果主进程异常退出（如 Ctrl+C、系统错误），Pool 的清理可能不完整
- Pool 中的工作进程可能因为异常而无法正常退出
- 工作进程中的子进程（subprocess.run）可能没有被正确清理

### 3. **subprocess.run 的子进程残留**

在 `process_sampling_task` 和 `process_evaluation_task` 中：
```python
result = subprocess.run(
    cmd,
    check=True,
    capture_output=True,
    timeout=3600,
    ...
)
```

**潜在问题**：
- 如果子进程因为CUDA错误、内存不足等原因挂起，`subprocess.run` 可能无法正常终止它
- 超时机制可能不够及时，进程在超时前就已经挂起
- 子进程可能创建了自己的子进程，形成进程树，但只终止了直接子进程

### 4. **CUDA 上下文未释放**

当进程因为CUDA错误（如 `CUBLAS_STATUS_NOT_INITIALIZED`）失败时：
- GPU内存可能没有被正确释放
- CUDA上下文可能保持打开状态
- 进程可能进入等待状态，无法正常退出

### 5. **异常处理不完整**

如果进程在异常处理过程中被中断：
- 异常处理代码可能没有执行到清理部分
- 资源（如GPU内存、文件句柄）可能没有被释放
- 进程可能进入僵尸状态

### 6. **进程间通信问题**

使用 `multiprocessing.Pool` 时：
- 如果工作进程在通信时阻塞，可能无法响应终止信号
- Manager 创建的共享对象可能导致进程无法正常退出

## 解决方案

### 1. **改进进程清理机制**

在 Pool 使用后显式清理：
```python
try:
    with Pool(processes=num_gpus) as pool:
        sampling_results = pool.map(process_sampling_task, sampling_tasks)
finally:
    pool.terminate()  # 强制终止所有工作进程
    pool.join()       # 等待进程完全退出
```

### 2. **改进 subprocess 管理**

使用 `Popen` 替代 `run`，以便更好地控制子进程：
```python
proc = subprocess.Popen(cmd, ...)
try:
    proc.wait(timeout=3600)
except subprocess.TimeoutExpired:
    proc.kill()  # 强制终止
    proc.wait()  # 等待完全退出
```

### 3. **添加信号处理**

在主进程中添加信号处理，确保优雅退出：
```python
import signal

def signal_handler(sig, frame):
    print("收到终止信号，正在清理...")
    pool.terminate()
    pool.join()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)
```

### 4. **添加进程监控和自动清理**

定期检查并清理挂起的进程：
```python
def cleanup_zombie_processes():
    # 检查并清理挂起的进程
    pass
```

### 5. **改进错误处理**

确保所有异常路径都能正确清理资源：
```python
try:
    # 执行任务
    pass
except Exception as e:
    # 清理资源
    cleanup_resources()
    raise
finally:
    # 确保资源被释放
    cleanup_resources()
```

## 当前状态

经过清理脚本处理后，所有残留进程已被清理。但为了避免未来再次出现此问题，建议实施上述改进措施。

